from classes.Bloc import Bloc
from classes.donnees import LISTE_DES_NOMS_PROFS, LISTE_DES_NOMS_GROUPES

class Calendrier:
    """
    Classe permettant d'analyser le fichier .ics afin d'en récupérer tous les Blocs
    """
    
    def __init__(self, url: str) -> None:
        self.url_fichier = url
        self.liste_evenements = [Bloc] # liste répertoriant tous les 'blocs' du fichier .ics

    def get_data(self, limite: int = -1):
        """
        limite : argument de debug pour limiter le nombre de lignes a parcourir
        pendant l'analyse du fichier (parcour toutes les lignes par défaut)
        """
        self.liste_evenements = parse_data(self.url_fichier, limite=limite)
    
    def get_events(self):
        """
        getter : retourne la liste contenant tous les 'blocs'
        """
        return self.liste_evenements


def create_data_bloc():
    """
    permet de créer le dictionnaire data_bloc contenant toutes les données
    """
    data_bloc = {
        "creneau": {
            "id"      : None,
            "intitule": None,
            "debut"   : None,
            "fin"     : None,
        },
        "professeur"  : None,
        "groupe"      : None, 
        "salle"       : None,
    }

    return data_bloc


def ajouter_debut(ligne: str) -> None:
    """
    permet d'ajouter ma date de debut du créneau dans le dictionnaire 
    """
    data_bloc["creneau"]["debut"] = ligne[8:-1]

def ajouter_fin(ligne: str) -> None:
    """
    permet d'ajouter ma date de debut du créneau dans le dictionnaire 
    """
    data_bloc["creneau"]["fin"] = ligne[6:-1]

def ajouter_intitule(ligne: str) -> None:
    """
    permet d'ajouter l'intitule du creneau
    """
    data_bloc["creneau"]["intitule"] = ligne[8:].removesuffix("\n")

def ajouter_UID(ligne: str) -> None:
    """
    permet d'ajouter l'UID du creneau
    """
    data_bloc["creneau"]["id"] = ligne[4:].removesuffix("\n")


def ajouter_salle(ligne: str) -> None:
    """
    permet d'ajouter la ou les salles utilisée(s) par le bloc.
    le cas sans salle est géré ici et le cas avec plusieurs salles est géré dans
    la classe 'Bloc'.
    """
    ligne = ligne.replace("\n", "").replace(",", "").replace("\\", ",")
    nouvelle_ligne = ligne[9:].split(",")

    if nouvelle_ligne[0] == "":
        # gestion du cas ou la salle n'existe pas
        data_bloc["salle"] = ["Null"]

    else:
        data_bloc["salle"] = nouvelle_ligne

def ajouter_prof(prof: list) -> None:
    if prof == []:
        data_bloc["professeur"] = "Null"
    else:
        data_bloc["professeur"] = prof

def ajouter_groupe(groupe: list) -> None:
    if groupe == []:
        data_bloc["groupe"] = "Null"
    else:
        data_bloc["groupe"] = ', '.join(groupe)



def get_ligne_complete(indice_ligne: int, liste_lignes: list) -> str:
    """
    arguments : 
        -indice_ligne: int -> indice de la ligne contenant la 'balise' description
        -liste_ligne: list -> la liste de toutes les lignes du fichier 

    retours: 
        -ligne_complete: str -> la ligne contenant la description complete

    Parcours les lignes du fichier a partir de la ligne description jusqu'à la ligne
    UID afin de récupérer la description complète car celle ci peut se trouver sur plusieurs lignes
    """
    ligne_complete: str = ""
    indice_temporaire = 0
    indice_temporaire += indice_ligne
    
    while not ("UID" in liste_lignes[indice_temporaire]):
        ligne_complete = ligne_complete + liste_lignes[indice_temporaire]
        indice_temporaire += 1

    return ligne_complete

def get_prof_groupe(ligne: str) -> tuple:
    """
    arguments : 
        ligne -> str : une ligne DESCRIPTION du fichier ical

    
    pour recuperer les informations, on utilise un split qui analyse la ligne
    elle passe outre les '\n' pour se concentrer sur le groupe et le professeur.
    Il peut y avoir de 0 a plusieurs groupes et de 0 a plusieurs professeurs.

    retours :
        -> (professeur, groupe_eleve) : le professeur et le groupe
    """

    ligne_analysee = ligne.replace("\\;", " ").split("\\n")

    # listes en compréhension
    groupes_liste = [element for element in ligne_analysee if element in LISTE_DES_NOMS_GROUPES]

    professeurs_liste = [element for element in ligne_analysee if element in LISTE_DES_NOMS_PROFS]

    return professeurs_liste, groupes_liste


def parse_data(url: str, limite: int) -> list:
    """
    arguments :
        url -> str : l'url du fichier a lire

    retours :
        liste_retours -> list : la liste de tous les blocs du calendrier

    fonction qui analyse le fichier .ics afin d'en extraire des objets de la classe 'Bloc'
    qui sont les objets utilisés pour ordonner les informations dans un fichier .csv

    on utilise un dictionnaire 'data_bloc' qui servira à stocker les informations d'un bloc
    puis sera utilisé pour instancier un objet 'Bloc'
    il contient : 
        - un créneau qui contient:
            - un identifiant
            - un intitule
            - une date de début
            - une date de fin

        - un ou plusieurs professeur(s) (objet 'Professeur')
        - un ou plusieurs groupe(s) (objet 'Groupe')
        - une ou plusieurs salle(s) (objet 'Salle')
    """

    liste_retour = []
    global data_bloc
    data_bloc = create_data_bloc()

    with open(url, encoding="utf-8") as fichier:
        liste_lignes = fichier.readlines()[0:limite] # parcours des lignes de 0 à la limite
                                                     # (par défaut jusqu'à la fin)

        for i, ligne in enumerate(liste_lignes): # enumerate permer de garder trace nu numéro
                                                 # de la ligne (utile plus tard) et de la ligne

            ligne = ligne.replace(";", ",") # on enlève les points virgule car ce sont des séparateurs 
                                            # de fichiers .csv
            
            # lorsque le creneau commence
            if ligne.startswith("BEGIN:VEVENT"):
                data_bloc = create_data_bloc()

            # recuperation de la date de debut
            if ligne.startswith("DTSTART"):
                ajouter_debut(ligne=ligne)
            
            elif ligne.startswith("DTEND"):
                ajouter_fin(ligne=ligne)

            # recuperation de la salle
            elif ligne.startswith("LOCATION"):
                ajouter_salle(ligne=ligne)
            
            # recuperation de la date de l'intitule
            #TODO Récupere si plusieur intitule dans la ligne. Ils sont séparé par un "\;"
            elif ligne.startswith("SUMMARY"):
                ajouter_intitule(ligne=ligne)

            # recuperation de la date du professeur et du groupe
            elif ligne.startswith("DESCRIPTION"):
                ligne_complete = get_ligne_complete(
                    indice_ligne=i,
                    liste_lignes=liste_lignes
                )

                prof, groupe = get_prof_groupe(ligne=ligne_complete)

                ajouter_prof(prof)

                ajouter_groupe(groupe)

            elif ligne.startswith("UID"):
                ajouter_UID(ligne)

            # la fin du creneau
            elif ligne.startswith("END:VEVENT"):
                # on crée un nouveau creneau et avec le dictionnaire data_bloc
                # on ajoute les données du bloc dedans
                # on l'ajoute ensuite a la liste des creneaux du calendrier
                bloc: Bloc = Bloc(data_bloc)
                liste_retour.append(bloc)
        
        return liste_retour



